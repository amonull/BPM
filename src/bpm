#!/bin/sh

# TODO: change some of the echos to printf to add colors (like red for [ERR]: and amber for [WARNING]: )

[ "$(id -u)" -eq 0 ] && (echo "bpm must be run as regular user (non-root)"; exit 1)

readonly starting_path="$(pwd)" # since path is changed (to a tmp dir in download_stage_1) it is not known if this will be required in future processes or not

readonly _version="v0.2_alpha"

packages_path="$HOME/.local/share/BPM/pkgs/" # in download_stage_3 pkg_name gets placed here (flag -p changes this location)
repos_path="$HOME/.local/share/BPM/templates/" # templates stored here (flag -r changes this location)
# readonly manpages_path="$HOME/.local/share/BPM/man/"

# [ flags ]
verbose=0
download=0
update=0
update_pkg=0
remove=0
search=0
check_updates=0
ignore_deps=0

flag_pkgs=""


#############################################
################ PREPERATION ################
#############################################

find_pkg () {
  readonly AMOUNT_FOUND
  readonly path_to_package
  readonly path_to_package_template

  AMOUNT_FOUND="$(find "$repos_path" -iname "$**" 2> /dev/null | wc -l)"

  if [ "$AMOUNT_FOUND" -gt 1 ] && [ ! "$search" ]; then
    echo "[WARNING]: found more than 1 package"
    echo "the packages found are:"
    echo ""
    find "$repos_path" -iname "$**" -exec echo {} \;
    echo ""
    echo "be more specific"
    exit 1
  fi

  path_to_package="$(find "$repos_path" -iname "$**" 2> /dev/null)"
  path_to_package_template="$path_to_package/Template"
}

source_template () {
  # sources a package variables
  
  if [ ! -d "$path_to_package_template" ]; then
    echo "package not found"
    exit 1
  fi

  # TODO: remove tr -d '"' with something else (especially in version) to not mess with {AUTO:*}

  # core package variables
  pkg_name="$(grep "Name" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"' || (echo "Name parameter not found"; exit 1))"
  pkg_version="$(grep "Version" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"' || (echo "Version parameter not found"; exit 1))"
  pkg_revision="$(grep "Revision" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"' || (echo "Revision parameter not found"; exit 1))"
  pkg_URL="$(grep "URL" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"' || (echo "URL not found"; exit 1))"

  # dependecies
  pkg_bpm_deps="$(grep "BPM_deps" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')"
  pkg_host_deps="$(grep "Host_deps" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')"

  # non-vital package variables
  pkg_conflicts="$(grep "Conflicts" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')"
  pkg_checksum=$(grep "Checksum" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')
  pkg_premissions=$(grep "Premissions" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')
  pkg_bin_premissions="644" # rw.r..r.. premissions by default
  pkg_file_premissions=""

  # package file variables
  pkg_manpages="$(grep "Manpages" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')"
  pkg_completion="$(grep "Completion" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')"
  pkg_desktop="$(grep "Desktop" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')"
  pkg_files=$(grep "Files" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')
  pkg_patches="$path_to_package/patches/"
  pkg_build="$path_to_package/build.sh"

  # fixing variables
  if echo "$pkg_manpages" | grep -qx "Manpages=\"{TEMPLATE}.*\""; then
    pkg_manpages="$(echo "$pkg_manpages" | sed "s|{TEMPLATE}|$FILE_PATH|g")"
  fi

  if echo "$pkg_completion" | grep -qx "Completion=\"{TEMPLATE}.*\""; then
    pkg_completion="$(echo "$pkg_completion" | sed "s|{TEMPLATE}|$FILE_PATH|g")"
  fi

  if echo "$pkg_desktop" | grep -qx "Desktop=\"{TEMPLATE}.*\""; then
    pkg_desktop="$(echo "$pkg_desktop" | sed "s|{TEMPLATE}|$FILE_PATH|g")"
  fi

  for premission in $pkg_premissions; do
    if echo "$premission" | grep -qx "\{BIN\}>[0-7][0-7][0-7]"; then
      pkg_bin_premissions="$(echo "$premission" | awk -F '>' '{print $2}')"
    else
      pkg_file_premissions="$pkg_file_premissions $premission"
    fi
  done
}

prepare_system () {
  # checks for dependecies and conflicts
  found_conflicts=""
  not_installed_host_deps=""
  not_installed_bpm_deps=""

  # XXX: consider using whereis instead of which

  for conflict in $pkg_conflicts; do
    which "$conflict" > /dev/null 2>&1 && found_conflicts="$found_conflicts $conflict"
  done

  if [ "$found_conflicts" ]; then
    echo "[ERR]: following conflicts were found on system:"
    echo ""
    for conflict in $found_conflicts; do 
      echo "$conflict"
    done
    echo ""
    echo "exiting..."
    exit 1
  fi

  for host_dep in $pkg_host_deps; do
    which "$host_dep" > /dev/null 2>&1 || not_installed_host_deps="$not_installed_host_deps $host_dep"
  done

  for bpm_dep in $pkg_bpm_deps; do
    which "$bpm_dep" > /dev/null 2>&1 || not_installed_bpm_deps="$not_installed_bpm_deps $bpm_dep"
  done

  if [ "$not_installed_host_deps" ]; then
    echo "[ERR]: following dependecies needs to be installed with host package manager:"
    echo ""
    for dep in $not_installed_host_deps; do
      echo "  $dep"
    done
    echo ""
    [ ! "$ignore_deps" ] && (echo "exiting..."; exit 1)
  fi

  if [ "$not_installed_bpm_deps" ]; then
    echo "[INFO]: found required BPM dependecies: "
    echo ""
    for dep in $not_installed_bpm_deps; do
      echo "  $dep"
    done
    echo ""
    read -r -p "install those dependecies? [y/N]: " response
    case "$response" in
      [yY])
        for install_dep in $not_installed_bpm_deps; do
          bpm -d "$install_dep" # assumes bpm is in path (self call)
        done
        ;;
      *)
        echo "[ERR]: dependecies are still required. Cannot install $pkg_name."
        [ ! "$ignore_deps" ] && (echo "exiting..."; exit 1)
        ;;
    esac
  fi
}


#############################################
################ DOWNLOADING ################
#############################################

download_stage_1 () {
  # gets all files from pkg_URL and puts into /tmp/BPM.XXXXXX/
  
  tmp_dir="$(mktemp -d -t BPM.XXXXXXXXXX)/"

  # XXX: PATH CHANGED HERE
  cd tmp_dir || (echo "[ERR]: cannot cd into created tmp dir: $tmp_dir"; exit 1)

  for url in $pkg_URL; do
    if echo "$url" | grep -q '\.git$' ; then
      git clone "$url" "$tmp_dir" || (echo "[ERR]: couldn't clone git repo: $url into $tmp_dir"; cleanup)
    else
      curl "$url" -o "$tmp_dir$(echo "$url" | awk -F '/' '{ print $NF }')" || (echo "[ERR]: couldn't curl $url into $tmp_dir"; cleanup)
    fi
  done
}

download_stage_2 () {
  # applies patches to files in /tmp/BPM.XXXXXX/
  # builds pkgs in /tmp/BPM.XXXXXX/
  
  # [ PATCHING ]
  for path in "$pkg_patches/"*; do
    if [ ! -f "$path" ]; then
      echo "[WARNING]: patch: $path is not a file. skipping..."
      continue
    fi

    file_to_patch="$(echo "$path" | awk -F '.' '{ print $1 }' )"

    patch -u "$file_to_patch" --input="$path" > /dev/null 2>&1 || (echo "[ERR]: couldn't apply patch: $path to $file_to_patch. exiting..."; cleanup)
  done

  # [ BUILDING ]
  echo ""
  cat "$pkg_build"
  echo ""

  read -r -p "Run build script above? [y/N]: " response
  case "$response" in
    [yY])
      echo "running $pkg_build inside $tmp_dir"
      sh "$pkg_build"
      ;;
    *)
      read -r -p "Not running build script. Exit [Y/n]: " response2
      case "$response2" in
        [nN])
          echo "[INFO]: $pkg_build didn't run. skipping checksums to avoid errors..."
          return
          ;;
        *)
          echo "exiting..."
          cleanup
          ;;
      esac
      ;;
  esac

  # [ CHECKSUM ]
  for checksum in $pkg_checksum; do
    file_name="$(echo "$checksum" | awk -F '>' '{ print $2 }')"
    checksum_method="$(echo "$checksum" | awk -F '>' '{ print $1 }' | tr -d '{')"
    expected_checksum_result="$(echo "$checksum" | awk -F '>' '{ print $2 }')"
    actual_checksum_result=$($checksum_method "$file_name" || (echo "[ERR]: error in making checksum file: $file_name"; exit 1))

    if [ ! "$expected_checksum_result" = "$actual_checksum_result" ]; then
      echo "[ERR]: checksums in file: $file_name do not match"
      echo "expected: $expected_checksum_result"
      echo "actual: $actual_checksum_result"
      echo "exiting..."

      cleanup
    fi
  done
}

download_stage_3 () {
  outdir="$packages_path/$pkg_name"
  man_outdir="$outdir/man"
  completions_outdir="$outdir/completions"
  desktop_outdir="$outdir/dekstop"
  files_outdir="$outdir/files"
  bin_outdir="$outdir/bin"
  info_file_outdir="$outdir/${pkg_name}_files__info" # simple txt file holding relative paths and where they are linked to i.e: man/man1/man.1  home/<user>/.local/share/man/man1/man.1
  mkdir -p "$outdir" "$man_outdir" "$completions_outdir" "$desktop_outdir" "$files_outdir" "$bin_outdir"
  touch "$info_file_outdir"

  echo "${pkg_version}_${pkg_revision}" >> "$info_file_outdir"

  # [ MANPAGES ]
  for manpage in $pkg_manpages; do
    ends_with=$(echo "$manpage" | awk -F '.' '{ print $2 }')
    end_path="$man_outdir/man$ends_with/"
    ln_path="$HOME/.local/share/man/man$ends_with/"

    # XXX: consider if error checking install should be used like in below
    install -Dm644 "$manpage" "$end_path"

    manpage="$(echo "$manpage" | awk -F '/' '{print $NF}')" # done incase $manpage used full path for template

    ln -s "$end_path/$manpage" "$ln_path"

    echo "$end_path $ln_path/$manpage" >> "$info_file_outdir"
  done

  # [ COMPLETION ]
  for completion in $pkg_completion; do
    completion_end_path="$completions_outdir/$(echo "$completion" | awk -F '/' '{print $NF}')"
    case $completion in
      *.fish)
        # XXX: consider if error checking install should be used like in below
        install -Dm644 "$completion" "$completion_end_path"
        ln -s "$completion_end_path" "$HOME/.local/share/fish/generated_completions/"
        echo "$completion_end_path" "$HOME/.local/share/fish/generated_completions/$(echo "$completion_end_path" | awk -F '/' '{print $NF}')" >> "$info_file_outdir"
        ;;
      *.bash)
        install -Dm644 "$completion" "$completion_end_path"
        ln -s "$completion_end_path" "$HOME/.local/share/bash-completion/completions/"
        echo "$completion_end_path" "$HOME/.local/share/bash-completion/completions/$(echo "$completion_end_path" | awk -F '/' '{print $NF}')" >> "$info_file_outdir"
        ;;
      *.zsh)
        echo TODO
        ;;
      *)
        ;;
    esac
  done

  # [ DESKTOP ]
  desktop_end_path="$desktop_outdir/$(echo "$pkg_desktop" | awk -F '/' '{print $NF}')"
  if install -Dm644 "$pkg_desktop" "$desktop_end_path" 2> /dev/null; then
    ln -s "$desktop_end_path" "$HOME/.local/share/applications/"
    echo "$desktop_end_path $HOME/.local/share/applications/$(echo "$desktop_end_path" | awk -F '/' '{print $NF}')" >> "$info_file_outdir"
  fi

  # [ BIN ]
  if [ "$pkg_name" = "{NONE}" ]; then
    pkg_name="$(echo "$path_to_package" | awk -F '/' '{print $NF}')"

    { echo "$pkg_name" ; echo "${pkg_version}_${pkg_revision}" ; echo "" ; echo "This package has no official binary. Check $info_file_outdir for more information on what was installed where." ; } > "$bin_outdir/$pkg_name"

    # XXX: alternative to above commented below incase above doesn't work

    # echo "$pkg_name" >> "$bin_outdir/$pkg_name"
    # echo "${pkg_version}_${pkg_revision}" >> "$bin_outdir/$pkg_name"
    # echo "" >> "$bin_outdir/$pkg_name"
    # echo "This package has no official binary. Check $info_file_outdir for more information on what was installed where." >> "$bin_outdir/$pkg_name"
  else
    if install -Dm"$pkg_bin_premissions" "$pkg_name" "$bin_outdir/$pkg_name"; then
      ln -s "$bin_outdir/$pkg_name" "$HOME/.local/bin/"
      echo "$bin_outdir/$pkg_name $HOME/.local/bin/$pkg_name" >> "$info_file_outdir"
    else
      echo "[ERR]: parameter Name is not {NONE} and $pkg_name does not exists in $tmp_dir"
      cleanup
    fi
  fi

  # [ FILES ]
  for file in $pkg_files; do
    file_loc="./$(echo "$file" | awk -F '>' '{ print $1 }' )"
    new_loc="$(echo "$file" | awk -F '>' '{ print $2 }' )"
    local_loc="$files_outdir/$(echo "$new_loc" | awk -F '/' '{print $NF}')"
    file_name="$(echo "$file_loc" | awk -F '/' '{print $NF}')"

    file_premission="$(echo "$pkg_file_premissions" | grep -o "$file_name>[0-7][0-7][0-7]" || echo "644")"]

    read -r -p "move file: $file_loc into $new_loc? [y/N]: " response
    case "$response" in
      [yY])
        if install -Dm"$file_premission" "$file_loc" "$local_loc"; then
          ln -s "$local_loc" "$new_loc"
          echo "$local_loc $new_loc" >> "$files_outdir"
        else
          echo "[WARNING]: File in: $file_loc does not exists"
          echo "skipping $file_loc..."
        fi
        ;;
      *)
        echo "skipping..."
        ;;
    esac
  done

  cd "$starting_path" || (echo "[ERR]: cannot cd into starting path: $starting_path"; cleanup)
  rm -rf "$tmp_dir"
}


#############################################
################# REMOVING ##################
#############################################

remove_pkg () {
  # TODO: following sym links from $info_file_outdir unlink all
  # sym links and then delete with rm -rf $outdir to remove everything
  # DO NOT FORGET TO REMOVE DEPENDECIES (just like in download before calling this func first source its template (if it exists if it doesnt warn user but continue) after sourcing it start removing deps or warn user those deps exist and should be removed)

  outdir="$packages_path/$pkg_name"
  info_file_outdir="$outdir/${pkg_name}_files__info" # simple txt file holding relative paths and where they are linked to i.e: man/man1/man.1  home/<user>/.local/share/man/man1/man.1
  paths_to_remove="$(tail -n +2 < "$info_file_outdir")"

  # [ removing deps ]
  if [ "$pkg_bpm_deps" ]; then
    echo "[INFO]: Found installed BPM deps: "
    for bpm_dep in $pkg_bpm_deps; do
      read -r -p "Remove $bpm_dep? [y/N]: " respone
      case "$respone" in
        [yY])
          bpm -R "$bpm_dep"
          ;;
        *)
          echo "[INFO]: not removing $bpm_dep"
          ;;
      esac
    done
  fi

  if [ "$pkg_host_deps" ]; then
    echo "[INFO]: Found installed host deps: "
    for host_dep in $pkg_host_deps; do
      echo "  $host_dep"
    done
  fi
  
  # [ removing symlinks and installed files ]
  for path in $paths_to_remove; do
    unlink "$(echo "$path" | awk '{print $2}')" || (echo "[WARNING]: cannot unlink: $(echo "$path" | awk '{print $2}')"; echo "skipping...")
  done

  rm -rf "$outdir"
}


#############################################
################# UPDATING ##################
#############################################

# TODO: for updating compare pkg_version and pkg_revision in info_file_outdir (located at first line)

update_checker () {
  echo "TODO"
}

full_update () {
  echo "TODO"
}

update_pkg () {
  echo "TODO"
}


#############################################
################## GENERAL ##################
#############################################

init () {
  # creates paths like $packages_path $manpages_path etc. and checks if bpm is on path
  echo "TODO"
}

cleanup () {
  rm -rf "$tmp_dir"
  exit 1
}

usage () {
  printf "
  usage: bpm [option(s)] [package]

  Options:
    -d, --download
      Download a package
  "
}


#############################################
################ START POINT ################
#############################################

[ $# -lt 1 ] && (echo "not enough parameters supplied"; usage) && exit 1

while [ $# -gt 0 ]; do
  case "$1" in
    -d | --download)
      shift
      download=1
      flag_pkgs="$*"
      ;;
    -s | --search)
      shift
      search=1
      flag_pkgs="$1"
      ;;
    -R | --remove)
      shift
      remove=1
      flag_pkgs="$*"
      ;;
    -u | --update)
      shift
      update=1
      flag_pkgs="$*"
      ;;
    -U | --update-pkg)
      shift
      update_pkg=1
      flag_pkgs="$*"
      ;;
    -c | --check-updates)
      shift
      check_updates=1
      ;;
    -I | --ignore-deps)
      shift
      ignore_deps=1
      ;;
    -r | --repo)
      repos_path="$1"
      shift
      flag_pkgs="$*"
      ;;
    -p | --path)
      packages_path="$1"
      shift
      flag_pkgs="$*"
      ;;
    -V | --verbose)
      shift
      verbose=1
      ;;
    -v | --version)
      echo $_version
      exit 0
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    *)
      echo ""
      usage
      exit 1
      ;;
  esac
  shift
done


init_bpm


# TODO: uncomment below when finished
# exit 0
