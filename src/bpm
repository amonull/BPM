#!/bin/sh

# TODO: change some of the echos to printf to add colors (like red for [ERR]: and amber for [WARNING]: )

[ "$(id -u)" -eq 0 ] && (echo "bpm must be run as regular user (non-root)"; exit 1)

readonly starting_path="$(pwd)" # since path is changed (to a tmp dir in download_stage_1) it is not known if this will be required in future processes or not

readonly _version="v0.2_alpha"

packages_path="$HOME/.local/share/BPM/pkgs/" # in download_stage_3 pkg_name gets placed here (flag -p changes this location)
repos_path="$HOME/.local/share/BPM/templates/" # templates stored here (flag -r changes this location)
tmp_dir="$(mktemp -d -t BPM.XXXXXXXXXX)/"

# [ flags ]
verbose=0
download=0
update=0
update_pkg=0
remove=0
search=0
check_updates=0
ignore_deps=0

flag_pkgs=""


#############################################
################## GENERAL ##################
#############################################

usage () {
  printf "
  usage: bpm [option(s)] [package]

  Options:
    -d, --download
      Download a package
  "
}

cleanup () {
  rm -rf "$tmp_dir"
  exit 1
}

cleanup_success () {
  rm -rf "$tmp_dir"
  exit 0
}

flush_vars () {
  # core package variables
  pkg_name=""
  pkg_version=""
  pkg_revision=""
  pkg_URL="" 

  # dependecies
  pkg_bpm_deps=""
  pkg_host_deps=""

  # non-vital pack
  pkg_conflicts=""
  pkg_checksum=""
  pkg_premissions=""
  pkg_bin_premissions=""
  pkg_file_premissions=""

  # package file variables
  pkg_manpages=""
  pkg_completion=""
  pkg_desktop=""
  pkg_files=""
  pkg_patches=""
  pkg_build=""
}


#############################################
################ PREPERATION ################
#############################################

find_pkg () {
  readonly AMOUNT_FOUND
  readonly path_to_package
  readonly path_to_package_template

  AMOUNT_FOUND="$(find "$repos_path" -iname "$**" 2> /dev/null | wc -l)"

  if [ "$AMOUNT_FOUND" -gt 1 ] && [ ! "$search" ]; then
    echo "[WARNING]: found more than 1 package"
    echo "the packages found are:"
    echo ""
    find "$repos_path" -iname "$**" -exec echo {} \;
    echo ""
    echo "be more specific"
    cleanup
  fi

  path_to_package="$(find "$repos_path" -iname "$**" 2> /dev/null)"
  path_to_package_template="$path_to_package/Template"
}

source_template () {
  # sources a package variables
  
  flush_vars
  
  if [ ! -d "$path_to_package_template" ]; then
    echo "package not found"
    cleanup
  fi

  # TODO: remove tr -d '"' with something else (especially in version) to not mess with {AUTO:*}

  # core package variables
  pkg_name="$(grep "Name" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"' || (echo "Name parameter not found"; cleanup))"
  pkg_version="$(grep "Version" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"' || (echo "Version parameter not found"; cleanup))"
  pkg_revision="$(grep "Revision" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"' || (echo "Revision parameter not found"; cleanup))"
  pkg_URL="$(grep "URL" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"' || (echo "URL not found"; cleanup))"

  # dependecies
  pkg_bpm_deps="$(grep "BPM_deps" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')"
  pkg_host_deps="$(grep "Host_deps" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')"

  # non-vital package variables
  pkg_conflicts="$(grep "Conflicts" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')"
  pkg_checksum=$(grep "Checksum" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')
  pkg_premissions=$(grep "Premissions" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')
  pkg_bin_premissions="644" # rw.r..r.. premissions by default
  pkg_file_premissions=""

  # package file variables
  pkg_manpages="$(grep "Manpages" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')"
  pkg_completion="$(grep "Completion" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')"
  pkg_desktop="$(grep "Desktop" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')"
  pkg_files=$(grep "Files" "$path_to_package_template" | awk -F '=' '{ print $2 }' | tr -d '"')
  pkg_patches="$path_to_package/patches/"
  pkg_build="$path_to_package/build.sh"

  # in second script | is used instead of / since using / used to give errors but in first | gives errors
  if echo "$pkg_manpages" | grep -qx "Manpages=\"{TEMPLATE}.*\""; then
    pkg_manpages="$(echo "$pkg_manpages" | sed "/{TEMPLATE}/!s/^/$tmp_dir/g")" # i hate regex
    pkg_manpages="$(echo "$pkg_manpages" | sed "s|{TEMPLATE}|$path_to_package_template|g")"
  fi

  if echo "$pkg_completion" | grep -qx "Completion=\"{TEMPLATE}.*\""; then
    pkg_completion="$(echo "$pkg_completion" | sed "/{TEMPLATE}/!s/^/$tmp_dir/g")"
    pkg_completion="$(echo "$pkg_completion" | sed "s|{TEMPLATE}|$path_to_package_template|g")"
  fi

  if echo "$pkg_desktop" | grep -qx "Desktop=\"{TEMPLATE}.*\""; then
    pkg_desktop="$(echo "$pkg_desktop" | sed sed "/{TEMPLATE}/!s/^/$tmp_dir/g")"
    pkg_desktop="$(echo "$pkg_desktop" | sed "s|{TEMPLATE}|$path_to_package_template|g")"
  fi

  for premission in $pkg_premissions; do
    if echo "$premission" | grep -qx "\{BIN\}>[0-7][0-7][0-7]"; then
      pkg_bin_premissions="$(echo "$premission" | awk -F '>' '{print $2}')"
    else
      pkg_file_premissions="$pkg_file_premissions $premission"
    fi
  done
}

prepare_system () {
  # checks for dependecies and conflicts
  found_conflicts=""
  not_installed_host_deps=""
  not_installed_bpm_deps=""

  # XXX: consider using whereis instead of which

  for conflict in $pkg_conflicts; do
    which "$conflict" > /dev/null 2>&1 && found_conflicts="$found_conflicts $conflict"
  done

  if [ "$found_conflicts" ]; then
    echo "[ERR]: following conflicts were found on system:"
    echo ""
    for conflict in $found_conflicts; do 
      echo "$conflict"
    done
    echo ""
    echo "exiting..."
    cleanup
  fi

  if [ ! "$ignore_deps" ]; then
    for host_dep in $pkg_host_deps; do
      which "$host_dep" > /dev/null 2>&1 || not_installed_host_deps="$not_installed_host_deps $host_dep"
    done

    for bpm_dep in $pkg_bpm_deps; do
      which "$bpm_dep" > /dev/null 2>&1 || not_installed_bpm_deps="$not_installed_bpm_deps $bpm_dep"
    done

    if [ "$not_installed_host_deps" ]; then
      echo "[ERR]: following dependecies needs to be installed with host package manager:"
      echo ""
      for dep in $not_installed_host_deps; do
        echo "  $dep"
      done
      echo ""
      echo "exiting..."
      cleanup
    fi

    if [ "$not_installed_bpm_deps" ]; then
      echo "[INFO]: found required BPM dependecies: "
      echo ""
      for dep in $not_installed_bpm_deps; do
        echo "  $dep"
      done
      echo ""
      read -r -p "install those dependecies? [y/N]: " response
      case "$response" in
        [yY])
          for install_dep in $not_installed_bpm_deps; do
            bpm -d "$install_dep" # assumes bpm is in path (self call)
          done
          ;;
        *)
          echo "[ERR]: dependecies are still required. Cannot install $pkg_name."
          echo "exiting..."
          cleanup
          ;;
      esac
    fi
  fi
}


#############################################
################ DOWNLOADING ################
#############################################

download_stage_1 () {
  # gets all files from pkg_URL and puts into /tmp/BPM.XXXXXX/
  
  # XXX: PATH CHANGED HERE
  cd tmp_dir || (echo "[ERR]: cannot cd into created tmp dir: $tmp_dir"; cleanup)

  for url in $pkg_URL; do
    if echo "$url" | grep -q '\.git$' ; then
      git clone "$url" "$tmp_dir" || (echo "[ERR]: couldn't clone git repo: $url into $tmp_dir"; cleanup)
    else
      curl "$url" -o "$tmp_dir$(echo "$url" | awk -F '/' '{ print $NF }')" || (echo "[ERR]: couldn't curl $url into $tmp_dir"; cleanup)
    fi
  done
}

download_stage_2 () {
  # applies patches to files in /tmp/BPM.XXXXXX/
  # builds pkgs in /tmp/BPM.XXXXXX/
  
  # [ PATCHING ]
  for path in "$pkg_patches"*; do
    if [ ! -f "$path" ]; then
      echo "[WARNING]: patch: $path is not a file. skipping..."
      continue
    fi

    file_to_patch="$(echo "$path" | awk -F '.' '{ print $1 }' )"

    patch -u "$file_to_patch" --input="$path" > /dev/null 2>&1 || (echo "[ERR]: couldn't apply patch: $path to $file_to_patch. exiting..."; cleanup)
  done

  # [ BUILDING ]
  echo ""
  cat "$pkg_build"
  echo ""

  read -r -p "Run build script above? [y/N]: " response
  case "$response" in
    [yY])
      echo "running $pkg_build inside $tmp_dir"
      sh "$pkg_build"
      ;;
    *)
      read -r -p "Not running build script. Exit [Y/n]: " response2
      case "$response2" in
        [nN])
          echo "[INFO]: $pkg_build didn't run. skipping checksums to avoid errors..."
          return
          ;;
        *)
          echo "exiting..."
          cleanup
          ;;
      esac
      ;;
  esac

  # [ CHECKSUM ]
  for checksum in $pkg_checksum; do
    file_name="$(echo "$checksum" | awk -F '>' '{ print $2 }')"
    checksum_method="$(echo "$checksum" | awk -F '>' '{ print $1 }' | tr -d '{')"
    expected_checksum_result="$(echo "$checksum" | awk -F '>' '{ print $2 }')"
    actual_checksum_result=$($checksum_method "$file_name" || (echo "[ERR]: error in making checksum file: $file_name"; cleanup))

    if [ ! "$expected_checksum_result" = "$actual_checksum_result" ]; then
      echo "[ERR]: checksums in file: $file_name do not match"
      echo "expected: $expected_checksum_result"
      echo "actual: $actual_checksum_result"
      echo "exiting..."

      cleanup
    fi
  done
}

download_stage_3 () {
  outdir="$packages_path/$(echo "$path_to_package" | awk -F '/' '{print $NF}')"
  man_outdir="$outdir/man"
  completions_outdir="$outdir/completions"
  desktop_outdir="$outdir/dekstop"
  files_outdir="$outdir/files"
  bin_outdir="$outdir/bin"
  info_file_outdir="$outdir/$(echo "$path_to_package" | awk -F '/' '{print $NF}')_files_info" # simple txt file holding relative paths and where they are linked to i.e: man/man1/man.1  home/<user>/.local/share/man/man1/man.1
  mkdir -p "$outdir" "$man_outdir" "$completions_outdir" "$desktop_outdir" "$files_outdir" "$bin_outdir"
  touch "$info_file_outdir"

  echo "${pkg_version}_${pkg_revision}" >> "$info_file_outdir"

  # [ MANPAGES ]
  for manpage in $pkg_manpages; do
    ends_with=$(echo "$manpage" | awk -F '.' '{ print $2 }')
    end_path="$man_outdir/man$ends_with/"
    ln_path="$HOME/.local/share/man/man$ends_with/"

    # XXX: consider if error checking install should be used like in below
    install -Dm644 "$manpage" "$end_path"

    manpage="$(echo "$manpage" | awk -F '/' '{print $NF}')" # done incase $manpage used full path for template

    ln -s "$end_path/$manpage" "$ln_path"

    echo "$end_path $ln_path/$manpage" >> "$info_file_outdir"
  done

  # [ COMPLETION ]
  for completion in $pkg_completion; do
    completion_end_path="$completions_outdir/$(echo "$completion" | awk -F '/' '{print $NF}')"
    case $completion in
      *.fish)
        # XXX: consider if error checking install should be used like in below
        install -Dm644 "$completion" "$completion_end_path"
        ln -s "$completion_end_path" "$HOME/.local/share/fish/generated_completions/"
        echo "$completion_end_path" "$HOME/.local/share/fish/generated_completions/$(echo "$completion_end_path" | awk -F '/' '{print $NF}')" >> "$info_file_outdir"
        ;;
      *.bash)
        install -Dm644 "$completion" "$completion_end_path"
        ln -s "$completion_end_path" "$HOME/.local/share/bash-completion/completions/"
        echo "$completion_end_path" "$HOME/.local/share/bash-completion/completions/$(echo "$completion_end_path" | awk -F '/' '{print $NF}')" >> "$info_file_outdir"
        ;;
      *.zsh)
        echo TODO
        ;;
      *)
        ;;
    esac
  done

  # [ DESKTOP ]
  desktop_end_path="$desktop_outdir/$(echo "$pkg_desktop" | awk -F '/' '{print $NF}')"
  if install -Dm644 "$pkg_desktop" "$desktop_end_path" 2> /dev/null; then
    ln -s "$desktop_end_path" "$HOME/.local/share/applications/"
    echo "$desktop_end_path $HOME/.local/share/applications/$(echo "$desktop_end_path" | awk -F '/' '{print $NF}')" >> "$info_file_outdir"
  fi

  # [ BIN ]
  if [ "$pkg_name" = "{NONE}" ]; then
    pkg_name="$(echo "$path_to_package" | awk -F '/' '{print $NF}')"

    { echo "$pkg_name" ; echo "${pkg_version}_${pkg_revision}" ; echo "" ; echo "This package has no official binary. Check $info_file_outdir for more information on what was installed where." ; } > "$bin_outdir/$pkg_name"

    # XXX: alternative to above commented below incase above doesn't work

    # echo "$pkg_name" >> "$bin_outdir/$pkg_name"
    # echo "${pkg_version}_${pkg_revision}" >> "$bin_outdir/$pkg_name"
    # echo "" >> "$bin_outdir/$pkg_name"
    # echo "This package has no official binary. Check $info_file_outdir for more information on what was installed where." >> "$bin_outdir/$pkg_name"
  else
    if install -Dm"$pkg_bin_premissions" "$tmp_dir/$pkg_name" "$bin_outdir/$pkg_name"; then
      ln -s "$bin_outdir/$pkg_name" "$HOME/.local/bin/"
      echo "$bin_outdir/$pkg_name $HOME/.local/bin/$pkg_name" >> "$info_file_outdir"
    else
      echo "[ERR]: parameter Name is not {NONE} and $pkg_name does not exists in $tmp_dir"
      cleanup
    fi
  fi

  # [ FILES ]
  for file in $pkg_files; do
    
    if [ "$(echo "$file" | awk -F '>' '{ print $1 }' )" = "{BIN}" ]; then
      file_loc="$pkg_name"
    else
      file_loc="$(echo "$file" | awk -F '>' '{ print $1 }' )"
    fi
    new_loc="$(echo "$file" | awk -F '>' '{ print $2 }' )"
    local_loc="$files_outdir/$(echo "$new_loc" | awk -F '/' '{print $NF}')"
    file_name="$(echo "$file_loc" | awk -F '/' '{print $NF}')"

    file_premission="$(echo "$pkg_file_premissions" | grep -o "$file_name>[0-7][0-7][0-7]" || echo "644")"]

    read -r -p "move file: $tmp_dir/$file_loc into $new_loc? [y/N]: " response
    case "$response" in
      [yY])
        if install -Dm"$file_premission" "$tmp_dir/$file_loc" "$local_loc"; then
          ln -s "$local_loc" "$new_loc"
          echo "$local_loc $new_loc" >> "$files_outdir"
        else
          echo "[WARNING]: File in: $file_loc does not exists"
          echo "skipping $file_loc..."
        fi
        ;;
      *)
        echo "skipping..."
        ;;
    esac
  done

  cd "$starting_path" || (echo "[ERR]: cannot cd into starting path: $starting_path"; cleanup)
  rm -rf "$tmp_dir"
}


#############################################
################# REMOVING ##################
#############################################

remove_pkg () {
  outdir="$packages_path/$pkg_name"
  info_file_outdir="$outdir/$(echo "$path_to_package" | awk -F '/' '{print $NF}')_files_info" # simple txt file holding relative paths and where they are linked to i.e: man/man1/man.1  home/<user>/.local/share/man/man1/man.1
  paths_to_remove="$(tail -n +2 < "$info_file_outdir")"

  # [ removing deps ]
  if [ "$pkg_bpm_deps" ]; then
    echo "[INFO]: Found installed BPM deps: "
    for bpm_dep in $pkg_bpm_deps; do
      read -r -p "Remove $bpm_dep? [y/N]: " respone
      case "$respone" in
        [yY])
          bpm -R "$bpm_dep"
          ;;
        *)
          echo "[INFO]: not removing $bpm_dep"
          ;;
      esac
    done
  fi

  if [ "$pkg_host_deps" ]; then
    echo "[INFO]: Found installed host deps: "
    for host_dep in $pkg_host_deps; do
      echo "  $host_dep"
    done
  fi
  
  # [ removing symlinks and installed files ]
  for path in $paths_to_remove; do
    unlink "$(echo "$path" | awk '{print $2}')" || (echo "[WARNING]: cannot unlink: $(echo "$path" | awk '{print $2}')"; echo "skipping...")
  done

  rm -rf "$outdir"
}


#############################################
################# UPDATING ##################
#############################################

update_checker () {
  needs_update=""

  for package in "$packages_path"/*; do
    current_package="$(echo "$package" | awk -F '/' '{print $NF}')"

    info_file_outdir="$package/${current_package}_files_info"
    current_version="$(head -n 1 < "$info_file_outdir")"

    find_pkg "$current_package"
    source_template
    
    if [ ! "$current_version" = "${pkg_version}_${pkg_revision}" ]; then
      needs_update="$needs_update $current_package"
    fi
  done

  echo "[INFO]: Following packages need to be updated"
  for package in $needs_update; do
    echo "  $package"
  done

  read -r -p "Update all now? [y/N]: " respone
  case "$respone" in
    [yY])
      bpm -u
      ;;
  esac
}

update_pkg () {
  current_package="$(echo "$flag_pkgs" | awk -F '/' '{print $NF}')"

  info_file_outdir="$package/${current_package}_files_info"
  current_version="$(head -n 1 < "$info_file_outdir")"

  find_pkg "$flag_pkgs"
  source_template

  if [ "$current_version" = "${pkg_version}_${pkg_revision}" ]; then
    echo "[INFO]: $flag_pkgs already on newest version on template"
    cleanup_success
  fi

  remove_pkg

  prepare_system

  download_stage_1
  download_stage_2
  download_stage_3
}

full_update () {
  needs_update=""

  for package in "$packages_path"/*; do
    current_package="$(echo "$package" | awk -F '/' '{print $NF}')"

    info_file_outdir="$package/${current_package}_files_info"
    current_version="$(head -n 1 < "$info_file_outdir")"

    find_pkg "$current_package"
    source_template
    
    if [ ! "$current_version" = "${pkg_version}_${pkg_revision}" ]; then
      needs_update="$needs_update $current_package"
    fi
  done

  for package in $needs_update; do
    flag_pkgs="$package"

    update_pkg
  done
}

#############################################
################ START POINT ################
#############################################

[ $# -lt 1 ] && (echo "not enough parameters supplied"; usage) && cleanup

while [ $# -gt 0 ]; do
  case "$1" in
    -d | --download)
      shift
      download=1
      flag_pkgs="$*"
      ;;
    -s | --search)
      shift
      search=1
      flag_pkgs="$1"
      ;;
    -R | --remove)
      shift
      remove=1
      flag_pkgs="$*"
      ;;
    -u | --update)
      shift
      update=1
      flag_pkgs="$*"
      ;;
    -U | --update-pkg)
      shift
      update_pkg=1
      flag_pkgs="$1"
      ;;
    -c | --check-updates)
      shift
      check_updates=1
      ;;
    -I | --ignore-deps)
      shift
      ignore_deps=1
      ;;
    -r | --repo)
      repos_path="$1"
      shift
      flag_pkgs="$*"
      ;;
    -p | --path)
      packages_path="$1"
      shift
      flag_pkgs="$*"
      ;;
    -V | --verbose)
      shift
      verbose=1
      ;;
    -v | --version)
      echo $_version
      cleanup_success
      ;;
    -h | --help)
      usage
      cleanup_success
      ;;
    *)
      echo ""
      usage
      cleanup
      ;;
  esac
  shift
done

if [ "$download" ]; then
  for package in $flag_pkgs; do
    find_pkg "$flag_pkgs"
    source_template
    prepare_system

    download_stage_1
    download_stage_2
    download_stage_3
  done

  cleanup_success
fi

if [ "$remove" ]; then
  for package in $flag_pkgs; do
    find_pkg "$package"
    remove_pkg
  done

  cleanup_success
fi

if [ "$search" ]; then
  find "$repos_path" -iname "$flag_pkgs"

  cleanup_success
fi

if [ "$update" ]; then
  full_update

  cleanup_success
fi

if [ "$update_pkg" ]; then
  update_pkg

  cleanup_success
fi

if [ "$check_updates" ]; then
  update_checker

  cleanup_success
fi

usage
cleanup
