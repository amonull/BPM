#!/bin/sh

# TODO: read downloaded and avaliable pkgs form an sqlite db (should make working with it faster)
# IDEAS:
#   checking pkgs use sqlite commands to check if item is in db
#   keep install instructions inside the db:
#     would mean making flag to compile sh command into the db and updating the db
#   download with purly db instructions
#   keep support for using sh without the db (as it is done now)

[ "$(id -u)" -eq 0 ] && echo "BPM must be run as non-root" && exit 1

_version="v0.1_alpha"

packages_path="$HOME/.local/BPM/pkgs/"
# repos_path="$HOME/.local/BPM/repo-list"
repos_path="$HOME/.local/share/BPM/repos/"
licence_path="$HOME~/.local/share/BPM/LICENCES/"

init () {
  if [ ! "$repos_path" ]; then
    git clone https://github.com/amonull/BPM
    mkdir -p "$repos_path"
    mv ./BPM/repo/main-repo.db "$repos_path"
    rm -rf ./BPM
  fi

  if [ ! "$packages_path" ]; then
    mkdir -p "$packages_path"
  fi

  if [ ! "$licence_path" ]; then
    mkdir -p "$licence_path"
  fi

  is_on_path=0

  case :$PATH: in
    *:"$packages_path":*)
      is_on_path=1
      ;;
  esac

  if [ ! $is_on_path ]; then
    echo "$packages_path is not on path."
  fi
}

#############################################
############ PKG INFO SOURCING ##############
#############################################

template_source () {
  # finding file
  FILE_PATH=$(find "$repos_path" -iname "$**" 2> /dev/null)
  AMOUNT_FOUND=$(find "$repos_path" -iname "$**" 2> /dev/null | wc -l) # calling $FILE_PATH in this command or when checking if this command is above 1 PREMISSION ERROR is given
  
  # if more than 1 file returned give error
  [ "$AMOUNT_FOUND" -gt 1 ] && (printf "found packages\n\n%s\n\nbe more specific" "$FILE_PATH"; exit 1)
  
  # sourcing file
  if [ -z "$FILE_PATH" ]; then
    echo "package not found"
    exit 1
  else
    . "$FILE_PATH"
  fi
  # [ -z "$FILE_PATH" ] && (echo "package not found"; exit 1) || . "$FILE_PATH"
}

#############################################
############# PKG DOWNLOAD ##################
#############################################

check_dependencies () {
  # With command below an install script for depndencies can be made as well
  user_package_manager=$( which dpkg 2> /dev/null ||          # deb based
                          which pacman 2> /dev/null ||        # arch based
                          which zypper 2> /dev/null ||        # suse based
                          which rpm 2> /dev/null ||           # red hat based
                          which xbps-install 2> /dev/null ||  # void based
                          which portage 2> /dev/null )        # gentoo based
  
  missing_deps=""
  missing_optional_deps=""

  # I only use xbps (void linux) so other commands haven't been tested and may not work
  case $user_package_manager in
    "/usr/bin/dpkg")
        for dependency in $DEPENDENCIES_DPKG; do
          dpkg -s "$dependency" > /dev/null 2>&1 || missing_deps="${missing_deps} $dependency"
        done
        for optional_dependency in $OPTIONAL_DEPENDENCIES_DPKG; do
          dpkg -s "$optional_dependency" > /dev/null 2>&1 || missing_optional_deps="${missing_optional_deps} $optional_dependency"
        done
        ;;
    "/usr/bin/pacman")
        for dependency in $DEPENDENCIES_PACMAN; do
          pacman -Qs "$dependency" > /dev/null 2>&1 || missing_deps="${missing_deps} $dependency"
        done
        for optional_dependency in $OPTIONAL_DEPENDENCIES_PACMAN; do
          pacman -Qs "$optional_dependency" > /dev/null 2>&1 || missing_optional_deps="${missing_optional_deps} $optional_dependency"
        done
        ;;
    "/usr/bin/zypper")
        for dependency in $DEPENDENCIES_ZYPPER; do
          zypper search "$dependency" > /dev/null 2>&1 || missing_deps="${missing_deps} $dependency"
        done
        for optional_dependency in $OPTIONAL_DEPENDENCIES_ZYPPER; do
          zypper search "$optional_dependency" > /dev/null 2>&1 || missing_optional_deps="${missing_optional_deps} $optional_dependency"
        done
        ;;
    "/usr/bin/rpm")
        for dependency in $DEPENDENCIES_RPM; do
          rpm -qa | grep -i "$dependency" > /dev/null 2>&1 || missing_deps="${missing_deps} $dependency"
        done
        for optional_dependency in $OPTIONAL_DEPENDENCIES_RPM; do
          rpm -qa | grep -i "$optional_dependency" > /dev/null 2>&1 || missing_optional_deps="${missing_optional_deps} $optional_dependency"
        done
        ;;
    "/usr/bin/xbps-install")
        for dependency in $DEPENDENCIES_XBPS; do
          xbps-query -l | awk '{print $2}' | grep -i "$dependency" > /dev/null 2>&1 || missing_deps="${missing_deps} $dependency"
        done
        for optional_dependency in $OPTIONAL_DEPENDENCIES_XBPS; do
          xbps-query -l | awk '{print $2}' | grep -i "$optional_dependency" > /dev/null 2>&1 || missing_optional_deps="${missing_optional_deps} $optional_dependency"
        done
        ;;
    "/usr/bin/portage")
        # dont know how to search for packages on gentoo
        for dependency in $DEPENDENCIES_PORTAGE; do
          which "$dependency" > /dev/null 2>&1 || missing_deps="${missing_deps} $dependency"
        done
        for optional_dependency in $OPTIONAL_DEPENDENCIES_PORTAGE; do
          which "$optional_dependency" > /dev/null 2>&1 || missing_optional_deps="${missing_optional_deps} $optional_dependency"
        done
        ;;
    *)
        echo "your package manager cannot be found. Listing debian (apk) dependencies"
        for dependency in $DEPENDENCIES_DPKG; do
          which "$dependency" > /dev/null 2>&1 || missing_deps="${missing_deps} $dependency"
        done
        for optional_dependency in $OPTIONAL_DEPENDENCIES_DPKG; do
          which "$optional_dependency" > /dev/null 2>&1 || missing_optional_deps="${missing_optional_deps} $optional_dependency"
        done
        ;;
      esac

      if [ -n "$missing_optional_deps" ]; then
        echo "Optional missing dependecies are:"
        echo "$missing_optional_deps" | tr ' ' '\n'
        echo ""
        # not exiting as it is optional
      fi
      if [ -n "$missing_deps" ]; then
        echo "Required missing dependecies are:"
        echo "$missing_deps" | tr ' ' '\n'
        exit 1 # exiting as it is Required
      fi
}

download_package () {
  # TODO: make moving file binaries into $HOME/.local/share/BPM/pkgs/ use 
  # relative path of tmp_dir so an entire repo can be moved
  # and add --path flag so that user chooses where the binaries get moved to
  # --path flag can also be set inside main-repo.db
  # when flag is set inside main-repo.db make it very clear to the user by
  # using printf and colors

  tmp_dir=$(mktemp -d -t BPM.XXXXXXXXXX)

  # DOWNLOAD_METHOD still used in eval incase it has extra options defined
  case "$DOWNLOAD_METHOD" in
    # singel quotes ('') needed for eval to treat it as an entire string/command and not setting vars
    "git clone"*)
      eval '$DOWNLOAD_METHOD' '$URL' '$tmp_dir' # --quiet
      ;;
    "curl"*)
eval '$DOWNLOAD_METHOD' '$URL' --output '$tmp_dir/outputFile' --progress-bar # --silent
      ;;
    "wget"*)
      eval '$DOWNLOAD_METHOD' '$URL' -O '$tmp_dir/outputFile' --show-progress --quiet
      ;;
    *)
      rm -rf "$tmp_dir"
      echo "package download method is wrong"
      exit 1
      ;;
  esac

  install_cmd # command created inside sourced file

  rm -rf "$tmp_dir"

  ln -s "$exe_path" "$HOME/.local/bin/$name"
}

remove_package () {
  remove_cmd # command created inside sourced file
  unlink "$HOME/.local/bin/$name"

  echo "$name removed"
  echo ""
  echo "installed Deps for this package were"
  echo ""

  user_package_manager=$(which dpkg 2> /dev/null || which pacman 2> /dev/null || which zypper 2> /dev/null || which rpm 2> /dev/null || which xbps-install 2> /dev/null || which portage 2> /dev/null)
  installed_deps=""
  installed_opt_deps=""
  case $user_package_manager in
    "/usr/bin/dpkg")
      for dependency in $DEPENDENCIES_DPKG; do
        dpkg -s "$dependency" > /dev/null 2>&1 && installed_deps="${installed_deps} $dependency"
      done
      for optional_dependency in $OPTIONAL_DEPENDENCIES_DPKG; do
        dpkg -s "$optional_dependency" > /dev/null 2>&1 && installed_opt_deps="${installed_opt_deps} $optional_dependency"
      done
      ;;
    "/usr/bin/pacman")
      for dependency in $DEPENDENCIES_PACMAN; do
        pacman -Qs "$dependency" > /dev/null 2>&1 && installed_deps="${installed_deps} $dependency"
      done
      for optional_dependency in $OPTIONAL_DEPENDENCIES_PACMAN; do
        pacman -Qs "$optional_dependency" > /dev/null 2>&1 && installed_opt_deps="${installed_opt_deps} $optional_dependency"
      done
      ;;
    "/usr/bin/zypper")
      for dependency in $DEPENDENCIES_ZYPPER; do
        zypper search "$dependency" > /dev/null 2>&1 && installed_deps="${installed_deps} $dependency"
      done
      for optional_dependency in $OPTIONAL_DEPENDENCIES_ZYPPER; do
        zypper search "$optional_dependency" > /dev/null 2>&1 && installed_opt_deps="${installed_opt_deps} $optional_dependency"
      done
      ;;
    "/usr/bin/rpm")
      for dependency in $DEPENDENCIES_RPM; do
        rpm -qa | grep -i "$dependency" > /dev/null 2>&1 && installed_deps="${installed_deps} $dependency"
      done
      for optional_dependency in $OPTIONAL_DEPENDENCIES_RPM; do
        rpm -qa | grep -i "$optional_dependency" > /dev/null 2>&1 && installed_opt_deps="${installed_opt_deps} $optional_dependency"
      done
      ;;
    "/usr/bin/xbps-install")
      for dependency in $DEPENDENCIES_XBPS; do
        xbps-query -l | awk '{print $2}' | grep -i "$dependency" > /dev/null 2>&1 && installed_deps="${installed_deps} $dependency"
      done
      for optional_dependency in $OPTIONAL_DEPENDENCIES_XBPS; do
        xbps-query -l | awk '{print $2}' | grep -i "$optional_dependency" > /dev/null 2>&1 && installed_opt_deps="${installed_opt_deps} $optional_dependency"
      done
      ;;
    "/usr/bin/portage")
      # dont know how to search for packages on gentoo
      for dependency in $DEPENDENCIES_PORTAGE; do
        which "$dependency" > /dev/null 2>&1 && installed_deps="${installed_deps} $dependency"
      done
      for optional_dependency in $OPTIONAL_DEPENDENCIES_PORTAGE; do
        which "$optional_dependency" > /dev/null 2>&1 && installed_opt_deps="${installed_opt_deps} $optional_dependency"
      done
      ;;
    *)
      echo "your package manager cannot be found. Listing debian (apk) dependencies"
      for dependency in $DEPENDENCIES_DPKG; do
        which "$dependency" > /dev/null 2>&1 && installed_deps="${installed_deps} $dependency"
      done
      for optional_dependency in $OPTIONAL_DEPENDENCIES_DPKG; do
        which "$optional_dependency" > /dev/null 2>&1 && installed_opt_deps="${installed_opt_deps} $optional_dependency"
      done
      ;;
    esac

    if [ -n "$installed_deps" ]; then
      echo "Required:"
      echo "$installed_deps" | tr ' ' '\n'
    fi
    if [ -n "$installed_opt_deps" ]; then
      echo "Optional:"
      echo "$installed_opt_deps" | tr ' ' '\n'
    fi

    exit 0
}

usage() {
  echo "usage:" 
  echo "  bpm [option(s)] [package]"
  echo "  bpm [option(s)]"
  echo ""
  echo "Options:"
  echo "  -d, --download <pkg name>"
  echo "      download package"
  echo "  -r, --remove <pkg name>"
  echo "      remove packge"
  echo "  -s, --search"
  echo "      search if a packge exists"
  echo "  -c, --check-updates"
  echo "      check for packages installed that need to be updated"
  echo "  -u, --update"
  echo "      update all package that need to be updated"
  echo "  -U, --update-pkg, <pkg name>"
  echo "      update a certain package"
  echo "  -R, --run, <program name>"
  echo "      run an installed program"
  echo "      IMPORTANT: will not run in program doesn't have run_cmd() defined in its template"
  echo "  -v --version"
  echo "      print version"
  echo "  -h, --help"
  echo "      print this screen"
}

#####################
#### START POINT ####
#####################

init

[ $# -lt 1 ] && (echo "not enough parameters supplied"; usage) && exit 1

while [ $# -gt 0 ]; do
  case "$1" in
    -d | --download)
      shift
      source_pkg "$*"
      check_dependencies
      download_package
      ;;
    -s | --search)
      shift
      find "$repos_path" -iname "$**" 2> /dev/null | awk -F "/" '{print $NF}' | awk -F '_' '{print $1}'
      ;;
    -r | --remove)
      shift
      source_pkg "$*"
      remove_package
      ;;
    -u | --update)
      shift
      update_packages
      ;;
    -U | --update-pkg)
      shift
      source_pkg "$*"
      update_cmd
      ;;
    -c | --check-updates)
      shift
      check_updates
      ;;
    -R | --run)
      shift
      source_pkg "$*"
      run_cmd
      ;;
    -v | --version)
      echo $_version
      exit 0
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    *)
      echo "no flags supplied"
      echo ""
      usage
      exit 1
      ;;
  esac
  shift
done

exit 0
